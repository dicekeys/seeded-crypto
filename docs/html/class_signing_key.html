<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DiceKeys Seeded Cryptography Library: SigningKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DiceKeys Seeded Cryptography Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_signing_key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_signing_key-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SigningKey Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SigningKeys generate <em>signatures</em> of messages which can then be used by the corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that a message was signed by can confirm that the message was indeed signed by the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> and has not since been tampered with.  
 <a href="class_signing_key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="signing-key_8hpp_source.html">signing-key.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab069912ec28952de43e5fd1722e4882c"><td class="memItemLeft" align="right" valign="top"><a id="ab069912ec28952de43e5fd1722e4882c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ab069912ec28952de43e5fd1722e4882c">SigningKey</a> (const <a class="el" href="class_signing_key.html">SigningKey</a> &amp;other)</td></tr>
<tr class="memdesc:ab069912ec28952de43e5fd1722e4882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of another <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a>. <br /></td></tr>
<tr class="separator:ab069912ec28952de43e5fd1722e4882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd5f01a3362569ce4b2c8640888f7a0"><td class="memItemLeft" align="right" valign="top"><a id="a7bd5f01a3362569ce4b2c8640888f7a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a7bd5f01a3362569ce4b2c8640888f7a0">SigningKey</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;<a class="el" href="class_signing_key.html#ace2901409405775e50558dd922b4d206">signingKeyBytes</a>, const std::string &amp;KeyDerivationOptionsJson)</td></tr>
<tr class="memdesc:a7bd5f01a3362569ce4b2c8640888f7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from the objects members, excluding the signature-verification key (which can be re-generated if needed) <br /></td></tr>
<tr class="separator:a7bd5f01a3362569ce4b2c8640888f7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb202728c57d2b7bfc4938bcd48eb9a7"><td class="memItemLeft" align="right" valign="top"><a id="aeb202728c57d2b7bfc4938bcd48eb9a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aeb202728c57d2b7bfc4938bcd48eb9a7">SigningKey</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;<a class="el" href="class_signing_key.html#ace2901409405775e50558dd922b4d206">signingKeyBytes</a>, const std::vector&lt; unsigned char &gt; &amp;<a class="el" href="class_signing_key.html#a39e4387a5f41cd898201b26a353f1870">signatureVerificationKeyBytes</a>, const std::string &amp;<a class="el" href="class_signing_key.html#a80f4bdaae02d6babc39fb2811b98b3b7">keyDerivationOptionsJson</a>)</td></tr>
<tr class="memdesc:aeb202728c57d2b7bfc4938bcd48eb9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from the objects members, excluding the signature-verification key. <br /></td></tr>
<tr class="separator:aeb202728c57d2b7bfc4938bcd48eb9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6dcf3c6ae07427813020889a74a2bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#abd6dcf3c6ae07427813020889a74a2bf">SigningKey</a> (const std::string &amp;seedString, const std::string &amp;<a class="el" href="class_signing_key.html#a80f4bdaae02d6babc39fb2811b98b3b7">keyDerivationOptionsJson</a>)</td></tr>
<tr class="memdesc:abd6dcf3c6ae07427813020889a74a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> by deriving a signing key pair from a seed string and a set of key-derivation options in <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON format</a>.  <a href="class_signing_key.html#abd6dcf3c6ae07427813020889a74a2bf">More...</a><br /></td></tr>
<tr class="separator:abd6dcf3c6ae07427813020889a74a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414c55c8b70ff01ac651ce668ad886ba"><td class="memItemLeft" align="right" valign="top"><a id="a414c55c8b70ff01ac651ce668ad886ba"></a>
const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a414c55c8b70ff01ac651ce668ad886ba">getSignatureVerificationKeyBytes</a> ()</td></tr>
<tr class="memdesc:a414c55c8b70ff01ac651ce668ad886ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw binary representation of the signature-verification key, re-deriving them from the signing key if signatureVerificationKeyBytes is a zero-length vector. <br /></td></tr>
<tr class="separator:a414c55c8b70ff01ac651ce668ad886ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdf0c3fc992f2c931711eabc3c7f526"><td class="memItemLeft" align="right" valign="top"><a id="a5fdf0c3fc992f2c931711eabc3c7f526"></a>
const <a class="el" href="class_signature_verification_key.html">SignatureVerificationKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a5fdf0c3fc992f2c931711eabc3c7f526">getSignatureVerificationKey</a> ()</td></tr>
<tr class="memdesc:a5fdf0c3fc992f2c931711eabc3c7f526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> which is used to verify signatures generated with this <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a>. <br /></td></tr>
<tr class="separator:a5fdf0c3fc992f2c931711eabc3c7f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad409117fbbf4bf199fe6cf890d40d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aa5ad409117fbbf4bf199fe6cf890d40d">generateSignature</a> (const unsigned char *message, const size_t messageLength) const</td></tr>
<tr class="memdesc:aa5ad409117fbbf4bf199fe6cf890d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a signature for a message which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key.  <a href="class_signing_key.html#aa5ad409117fbbf4bf199fe6cf890d40d">More...</a><br /></td></tr>
<tr class="separator:aa5ad409117fbbf4bf199fe6cf890d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856e47b69b3a643eb2b4ecf2457a2b7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ad856e47b69b3a643eb2b4ecf2457a2b7">generateSignature</a> (const std::vector&lt; unsigned char &gt; &amp;message) const</td></tr>
<tr class="memdesc:ad856e47b69b3a643eb2b4ecf2457a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a signature for a message, which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key.  <a href="class_signing_key.html#ad856e47b69b3a643eb2b4ecf2457a2b7">More...</a><br /></td></tr>
<tr class="separator:ad856e47b69b3a643eb2b4ecf2457a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90c574b9d092ac2a6be89fc8b05cad1"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aa90c574b9d092ac2a6be89fc8b05cad1">toJson</a> (bool minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater=true, int indent=-1, const char indent_char=' ') const</td></tr>
<tr class="memdesc:aa90c574b9d092ac2a6be89fc8b05cad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this object to a JSON-formatted string.  <a href="class_signing_key.html#aa90c574b9d092ac2a6be89fc8b05cad1">More...</a><br /></td></tr>
<tr class="separator:aa90c574b9d092ac2a6be89fc8b05cad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed9b246e692a0c3a67735eb12c4fe28"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a9ed9b246e692a0c3a67735eb12c4fe28">toSerializedBinaryForm</a> (bool minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater=true) const</td></tr>
<tr class="memdesc:a9ed9b246e692a0c3a67735eb12c4fe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to byte array as a list of: (keyBytes, signatureVerificationKeyBytes, keyDerivationOptionsJson)  <a href="class_signing_key.html#a9ed9b246e692a0c3a67735eb12c4fe28">More...</a><br /></td></tr>
<tr class="separator:a9ed9b246e692a0c3a67735eb12c4fe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4bdf9ebd2d3cc82b7bb2b2482514cb4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_signing_key.html">SigningKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a4bdf9ebd2d3cc82b7bb2b2482514cb4c">fromJson</a> (const std::string &amp;signingKeyAsJson)</td></tr>
<tr class="memdesc:a4bdf9ebd2d3cc82b7bb2b2482514cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct (reconsitute) the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> from JSON format. The JSON object may or may not contain the signatureVerificationKeyBytes. If it does not, an empty byte vector will be stored and the verification key bytes will be re-derived from the signing key by getSignatureVerificationKeyBytes if they are needed.  <a href="class_signing_key.html#a4bdf9ebd2d3cc82b7bb2b2482514cb4c">More...</a><br /></td></tr>
<tr class="separator:a4bdf9ebd2d3cc82b7bb2b2482514cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f1df513bf5b00592a7f90df519da4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_signing_key.html">SigningKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ac34f1df513bf5b00592a7f90df519da4">fromSerializedBinaryForm</a> (<a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> serializedBinaryForm)</td></tr>
<tr class="memdesc:ac34f1df513bf5b00592a7f90df519da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize from a byte array stored as a list of: (keyBytes, signatureVerificationKeyBytes, keyDerivationOptionsJson)  <a href="class_signing_key.html#ac34f1df513bf5b00592a7f90df519da4">More...</a><br /></td></tr>
<tr class="separator:ac34f1df513bf5b00592a7f90df519da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ace2901409405775e50558dd922b4d206"><td class="memItemLeft" align="right" valign="top"><a id="ace2901409405775e50558dd922b4d206"></a>
const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ace2901409405775e50558dd922b4d206">signingKeyBytes</a></td></tr>
<tr class="memdesc:ace2901409405775e50558dd922b4d206"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw binary representation of the cryptographic signing key. <br /></td></tr>
<tr class="separator:ace2901409405775e50558dd922b4d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f4bdaae02d6babc39fb2811b98b3b7"><td class="memItemLeft" align="right" valign="top"><a id="a80f4bdaae02d6babc39fb2811b98b3b7"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a80f4bdaae02d6babc39fb2811b98b3b7">keyDerivationOptionsJson</a></td></tr>
<tr class="memdesc:a80f4bdaae02d6babc39fb2811b98b3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON format</a> string used to specify how this key is derived. <br /></td></tr>
<tr class="separator:a80f4bdaae02d6babc39fb2811b98b3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a39e4387a5f41cd898201b26a353f1870"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a39e4387a5f41cd898201b26a353f1870">signatureVerificationKeyBytes</a></td></tr>
<tr class="memdesc:a39e4387a5f41cd898201b26a353f1870"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>May</em> store the byte representation of this <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a>'s corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a>.  <a href="class_signing_key.html#a39e4387a5f41cd898201b26a353f1870">More...</a><br /></td></tr>
<tr class="separator:a39e4387a5f41cd898201b26a353f1870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SigningKeys generate <em>signatures</em> of messages which can then be used by the corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that a message was signed by can confirm that the message was indeed signed by the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> and has not since been tampered with. </p>
<p>The corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> can be obtained by calling getSignatureVerificationKey.</p>
<p>The key pair of the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> and <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> is generated from a seed and a set of key-derivation specified options in <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON format</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abd6dcf3c6ae07427813020889a74a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6dcf3c6ae07427813020889a74a2bf">&#9670;&nbsp;</a></span>SigningKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SigningKey::SigningKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seedString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyDerivationOptionsJson</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> by deriving a signing key pair from a seed string and a set of key-derivation options in <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON format</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedString</td><td>The private seed which is used to generate the key pair. Anyone who knows (or can guess) this seed can re-generate the key pair by passing it along with the keyDerivationOptionsJson. </td></tr>
    <tr><td class="paramname">keyDerivationOptionsJson</td><td>The key-derivation options in <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON format</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4bdf9ebd2d3cc82b7bb2b2482514cb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdf9ebd2d3cc82b7bb2b2482514cb4c">&#9670;&nbsp;</a></span>fromJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_signing_key.html">SigningKey</a> SigningKey::fromJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signingKeyAsJson</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct (reconsitute) the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> from JSON format. The JSON object may or may not contain the signatureVerificationKeyBytes. If it does not, an empty byte vector will be stored and the verification key bytes will be re-derived from the signing key by getSignatureVerificationKeyBytes if they are needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signingKeyAsJson</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac34f1df513bf5b00592a7f90df519da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34f1df513bf5b00592a7f90df519da4">&#9670;&nbsp;</a></span>fromSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_signing_key.html">SigningKey</a> SigningKey::fromSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td>
          <td class="paramname"><em>serializedBinaryForm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize from a byte array stored as a list of: (keyBytes, signatureVerificationKeyBytes, keyDerivationOptionsJson) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A buffer class which uses memory that is erased before the memory is released for re-use by other obj...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays. </p>

</div>
</div>
<a id="ad856e47b69b3a643eb2b4ecf2457a2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad856e47b69b3a643eb2b4ecf2457a2b7">&#9670;&nbsp;</a></span>generateSignature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; SigningKey::generateSignature </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a signature for a message, which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to <em>sign</em> by generating the signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; A signature, which can be used with the <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to prove that this act of signing (this call to generateSignature) took place. </dd></dl>

</div>
</div>
<a id="aa5ad409117fbbf4bf199fe6cf890d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ad409117fbbf4bf199fe6cf890d40d">&#9670;&nbsp;</a></span>generateSignature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; SigningKey::generateSignature </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a signature for a message which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to <em>sign</em> by generating the signature </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; A signature, which can be used with the <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to prove that this act of signing (this call to generateSignature) took place. </dd></dl>

</div>
</div>
<a id="aa90c574b9d092ac2a6be89fc8b05cad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90c574b9d092ac2a6be89fc8b05cad1">&#9670;&nbsp;</a></span>toJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SigningKey::toJson </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize this object to a JSON-formatted string. </p>
<p>It can be reconstituted by calling the constructor with this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater</td><td>The JSON-encoding will always include the binary signing key bytes (in hex format) and the keyDerviationOptionsJson used to derive the key, but the signature-verification key bytes will not be included unless you set this value to false. Rather, if it is elided, the signature-verification key can be reconstituted from the signing-key after the object is reconstituted, which takes a little computation in return for the space saved in the JSON format. </td></tr>
    <tr><td class="paramname">indent</td><td>The number of characters to indent the JSON (optional) </td></tr>
    <tr><td class="paramname">indent_char</td><td>The character with which to indent the JSON (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string </dd></dl>

</div>
</div>
<a id="a9ed9b246e692a0c3a67735eb12c4fe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed9b246e692a0c3a67735eb12c4fe28">&#9670;&nbsp;</a></span>toSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SigningKey::toSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize to byte array as a list of: (keyBytes, signatureVerificationKeyBytes, keyDerivationOptionsJson) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A buffer class which uses memory that is erased before the memory is released for re-use by other obj...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater</td><td>If set to true (the default), an empty buffer will be passed for the signatureVerificationKeyBytes. After the object is deserialized, the replica can re-generate a signature-verification key from the signing key, which takes a little computation in return for the 28 bytes saved in this format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39e4387a5f41cd898201b26a353f1870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e4387a5f41cd898201b26a353f1870">&#9670;&nbsp;</a></span>signatureVerificationKeyBytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; SigningKey::signatureVerificationKeyBytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>May</em> store the byte representation of this <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a>'s corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a>. </p>
<p>When a signing key is generated, it's corresponding signature-verification key is generated with it. However, it can also be re-generated from the signature-verification key. Thus, storing the signature-verification key is more a matter of efficiency than necessity. We store it by default.</p>
<p>However, when a <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> is encoded into JSON format, the default representation elides the verificaiton key since it can be re-generated if needed so that the encoding is more compact. If this signing-key is reconsistuted from JSON format, the signatureVerificationKeyBytes will be empty (a zero-length vector) and it will only be re-generated when <a class="el" href="class_signing_key.html#a414c55c8b70ff01ac651ce668ad886ba" title="Get the raw binary representation of the signature-verification key, re-deriving them from the signin...">getSignatureVerificationKeyBytes()</a> is called. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/<a class="el" href="signing-key_8hpp_source.html">signing-key.hpp</a></li>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/signing-key.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_signing_key.html">SigningKey</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
