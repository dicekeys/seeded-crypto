<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DiceKeys Seeded Cryptography Library: SymmetricKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DiceKeys Seeded Cryptography Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_symmetric_key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_symmetric_key-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SymmetricKey Class Reference<div class="ingroups"><a class="el" href="group___derived_from_seeds.html">Derived Keys</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> can be used to seal and unseal messages. This <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> class can be (re) derived from a seed using set of recipe specified in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. So, you can use this symmetric-key to seal a message, throw the key away, and re-generate the key when you need to unseal the message so long as you still have the original seed and recipe.  
 <a href="class_symmetric_key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="symmetric-key_8hpp_source.html">symmetric-key.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91ffef7a493c964ce33ce533a4df36c3"><td class="memItemLeft" align="right" valign="top"><a id="a91ffef7a493c964ce33ce533a4df36c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a91ffef7a493c964ce33ce533a4df36c3">SymmetricKey</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;<a class="el" href="class_symmetric_key.html#a3c037459d7ccb3c6eac890d9eceb3289">keyBytes</a>, std::string <a class="el" href="class_symmetric_key.html#a00468e9b1fbf07a1a851c39753ddbefd">recipe</a>)</td></tr>
<tr class="memdesc:a91ffef7a493c964ce33ce533a4df36c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from its members. <br /></td></tr>
<tr class="separator:a91ffef7a493c964ce33ce533a4df36c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4093b83e9bfd58af4e3f77b3289f3039"><td class="memItemLeft" align="right" valign="top"><a id="a4093b83e9bfd58af4e3f77b3289f3039"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a4093b83e9bfd58af4e3f77b3289f3039">SymmetricKey</a> (const <a class="el" href="class_symmetric_key.html">SymmetricKey</a> &amp;other)</td></tr>
<tr class="memdesc:a4093b83e9bfd58af4e3f77b3289f3039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> by copying another one. <br /></td></tr>
<tr class="separator:a4093b83e9bfd58af4e3f77b3289f3039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad251d922423ab480558e97b31012293f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#ad251d922423ab480558e97b31012293f">SymmetricKey</a> (const std::string &amp;seedString, const std::string &amp;<a class="el" href="class_symmetric_key.html#a00468e9b1fbf07a1a851c39753ddbefd">recipe</a>)</td></tr>
<tr class="memdesc:ad251d922423ab480558e97b31012293f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> by (re)deriving it from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>.  <a href="class_symmetric_key.html#ad251d922423ab480558e97b31012293f">More...</a><br /></td></tr>
<tr class="separator:ad251d922423ab480558e97b31012293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9a9e571e4ea58c25ea64d4f8679b0a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a1b9a9e571e4ea58c25ea64d4f8679b0a">sealToCiphertextOnly</a> (const unsigned char *message, const size_t messageLength, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a1b9a9e571e4ea58c25ea64d4f8679b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_symmetric_key.html#a1b9a9e571e4ea58c25ea64d4f8679b0a">More...</a><br /></td></tr>
<tr class="separator:a1b9a9e571e4ea58c25ea64d4f8679b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bad48113a156c2d020509d45cdb2e6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a98bad48113a156c2d020509d45cdb2e6">sealToCiphertextOnly</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;message, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a98bad48113a156c2d020509d45cdb2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_symmetric_key.html#a98bad48113a156c2d020509d45cdb2e6">More...</a><br /></td></tr>
<tr class="separator:a98bad48113a156c2d020509d45cdb2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9b903963307affd8b0208b8e3c405d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a9f9b903963307affd8b0208b8e3c405d">seal</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;message, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a9f9b903963307affd8b0208b8e3c405d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_symmetric_key.html#a9f9b903963307affd8b0208b8e3c405d">More...</a><br /></td></tr>
<tr class="separator:a9f9b903963307affd8b0208b8e3c405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd00fb5e887c18a0e7abd6a8eca25d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a91dd00fb5e887c18a0e7abd6a8eca25d">seal</a> (const std::string &amp;message, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a91dd00fb5e887c18a0e7abd6a8eca25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_symmetric_key.html#a91dd00fb5e887c18a0e7abd6a8eca25d">More...</a><br /></td></tr>
<tr class="separator:a91dd00fb5e887c18a0e7abd6a8eca25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7806c51b1f13910a077d9477a332ad4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#ab7806c51b1f13910a077d9477a332ad4">seal</a> (const std::vector&lt; unsigned char &gt; &amp;message, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:ab7806c51b1f13910a077d9477a332ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_symmetric_key.html#ab7806c51b1f13910a077d9477a332ad4">More...</a><br /></td></tr>
<tr class="separator:ab7806c51b1f13910a077d9477a332ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3facff0484c08bf0bcf478bf1e31afe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#ad3facff0484c08bf0bcf478bf1e31afe">seal</a> (const unsigned char *message, const size_t messageLength, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:ad3facff0484c08bf0bcf478bf1e31afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_symmetric_key.html#ad3facff0484c08bf0bcf478bf1e31afe">More...</a><br /></td></tr>
<tr class="separator:ad3facff0484c08bf0bcf478bf1e31afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7f30cb5066e2cc943aa3490b2a58e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a8b7f30cb5066e2cc943aa3490b2a58e8">unseal</a> (const unsigned char *ciphertext, const size_t ciphertextLength, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a8b7f30cb5066e2cc943aa3490b2a58e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unseal a message.  <a href="class_symmetric_key.html#a8b7f30cb5066e2cc943aa3490b2a58e8">More...</a><br /></td></tr>
<tr class="separator:a8b7f30cb5066e2cc943aa3490b2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835fa33240e815ee23d822dd58bae669"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a835fa33240e815ee23d822dd58bae669">unseal</a> (const std::vector&lt; unsigned char &gt; &amp;ciphertext, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a835fa33240e815ee23d822dd58bae669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unseal a message.  <a href="class_symmetric_key.html#a835fa33240e815ee23d822dd58bae669">More...</a><br /></td></tr>
<tr class="separator:a835fa33240e815ee23d822dd58bae669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2300f36bf74e3d64dc71c35e81d32e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#aea2300f36bf74e3d64dc71c35e81d32e">unseal</a> (const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> &amp;packagedSealedMessage) const</td></tr>
<tr class="memdesc:aea2300f36bf74e3d64dc71c35e81d32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unseal a message by re-deriving the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from a seed.  <a href="class_symmetric_key.html#aea2300f36bf74e3d64dc71c35e81d32e">More...</a><br /></td></tr>
<tr class="separator:aea2300f36bf74e3d64dc71c35e81d32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f3752039f5735b504f071d710ac01b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a94f3752039f5735b504f071d710ac01b">toJson</a> (int indent=-1, const char indent_char=' ') const</td></tr>
<tr class="memdesc:a94f3752039f5735b504f071d710ac01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this object to a JSON-formatted string.  <a href="class_symmetric_key.html#a94f3752039f5735b504f071d710ac01b">More...</a><br /></td></tr>
<tr class="separator:a94f3752039f5735b504f071d710ac01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1f3f4afd908aba2f5780f2248a8f47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#aac1f3f4afd908aba2f5780f2248a8f47">toSerializedBinaryForm</a> () const</td></tr>
<tr class="memdesc:aac1f3f4afd908aba2f5780f2248a8f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to byte array as a list of: (keyBytes, recipe)  <a href="class_symmetric_key.html#aac1f3f4afd908aba2f5780f2248a8f47">More...</a><br /></td></tr>
<tr class="separator:aac1f3f4afd908aba2f5780f2248a8f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6189ca51ec682a30a1c440231a0ef9c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_symmetric_key.html">SymmetricKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a6189ca51ec682a30a1c440231a0ef9c4">deriveFromSeed</a> (const std::string &amp;seedString, const std::string &amp;<a class="el" href="class_symmetric_key.html#a00468e9b1fbf07a1a851c39753ddbefd">recipe</a>)</td></tr>
<tr class="memdesc:a6189ca51ec682a30a1c440231a0ef9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> by (re)deriving it from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>.  <a href="class_symmetric_key.html#a6189ca51ec682a30a1c440231a0ef9c4">More...</a><br /></td></tr>
<tr class="separator:a6189ca51ec682a30a1c440231a0ef9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74190d5c5f3a46e6c5f4e131e6f3d5a1"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a74190d5c5f3a46e6c5f4e131e6f3d5a1">unseal</a> (const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> &amp;packagedSealedMessage, const std::string &amp;seedString)</td></tr>
<tr class="memdesc:a74190d5c5f3a46e6c5f4e131e6f3d5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unseal a message by re-deriving the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from a seed.  <a href="class_symmetric_key.html#a74190d5c5f3a46e6c5f4e131e6f3d5a1">More...</a><br /></td></tr>
<tr class="separator:a74190d5c5f3a46e6c5f4e131e6f3d5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96161ba0e7d4d96ccd30dfd7d47787e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_symmetric_key.html">SymmetricKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a96161ba0e7d4d96ccd30dfd7d47787e9">fromSerializedBinaryForm</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;serializedBinaryForm)</td></tr>
<tr class="memdesc:a96161ba0e7d4d96ccd30dfd7d47787e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize from a byte array stored as a list of: (keyBytes, recipe)  <a href="class_symmetric_key.html#a96161ba0e7d4d96ccd30dfd7d47787e9">More...</a><br /></td></tr>
<tr class="separator:a96161ba0e7d4d96ccd30dfd7d47787e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3534a81bb11dfc32b8b43b60b5a52a05"><td class="memItemLeft" align="right" valign="top"><a id="a3534a81bb11dfc32b8b43b60b5a52a05"></a>
static <a class="el" href="class_symmetric_key.html">SymmetricKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a3534a81bb11dfc32b8b43b60b5a52a05">fromJson</a> (const std::string &amp;symmetricKeyAsJson)</td></tr>
<tr class="memdesc:a3534a81bb11dfc32b8b43b60b5a52a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation of JSON parser for the JSON contructor. <br /></td></tr>
<tr class="separator:a3534a81bb11dfc32b8b43b60b5a52a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3c037459d7ccb3c6eac890d9eceb3289"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a3c037459d7ccb3c6eac890d9eceb3289">keyBytes</a></td></tr>
<tr class="memdesc:a3c037459d7ccb3c6eac890d9eceb3289"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary representation of the symmetric key.  <a href="class_symmetric_key.html#a3c037459d7ccb3c6eac890d9eceb3289">More...</a><br /></td></tr>
<tr class="separator:a3c037459d7ccb3c6eac890d9eceb3289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00468e9b1fbf07a1a851c39753ddbefd"><td class="memItemLeft" align="right" valign="top"><a id="a00468e9b1fbf07a1a851c39753ddbefd"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a00468e9b1fbf07a1a851c39753ddbefd">recipe</a></td></tr>
<tr class="memdesc:a00468e9b1fbf07a1a851c39753ddbefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="recipe_format.html">JSON Format for Recipes</a> string used to specify how this key is derived. <br /></td></tr>
<tr class="separator:a00468e9b1fbf07a1a851c39753ddbefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1b5afa62f4fa6b33819bd5a15b86501b"><td class="memItemLeft" align="right" valign="top"><a id="a1b5afa62f4fa6b33819bd5a15b86501b"></a>
const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_symmetric_key.html#a1b5afa62f4fa6b33819bd5a15b86501b">unsealMessageContents</a> (const unsigned char *ciphertext, const size_t ciphertextLength, const std::string &amp;unsealingInstructions={}) const</td></tr>
<tr class="memdesc:a1b5afa62f4fa6b33819bd5a15b86501b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation of unseal. <br /></td></tr>
<tr class="separator:a1b5afa62f4fa6b33819bd5a15b86501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> can be used to seal and unseal messages. This <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> class can be (re) derived from a seed using set of recipe specified in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. So, you can use this symmetric-key to seal a message, throw the key away, and re-generate the key when you need to unseal the message so long as you still have the original seed and recipe. </p>
<p>Sealing a message (<em>plaintext</em>) creates a _ciphertext which contains the message but from which observers who do not have the <a class="el" href="class_unsealing_key.html" title="an UnsealingKey is used to unseal messages sealed with its corresponding SealingKey....">UnsealingKey</a> cannot discern the contents of the message. Sealing also provides integrity-protection, which will preven the message from being unsealed if it is modified. We use the verbs seal and unseal, rather than encrypt and decrypt, because the encrypting alone does not confer that the message includes an integrity (message authentication) code to prove that the ciphertext has not been tampered with.</p>
<p>The seal operation is built on LibSodium's crypto_secretbox_easy function, but despite it's name the construct isn't as easy as it should be. The caller must store both the ciphertext AND a 24-byte nonce (crypto_secretbox_NONCEBYTES = 24). Hence, the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> seal operation outputs a <em>composite</em> ciphertext containing the nonce followed by the "secret box" ciphertext generated by LibSodium. Since the "secret box" is 16 bytes longer than the message size (crypto_secretbox_MACBYTES = 16), the composite ciphertext is is 40 bytes longer than the message length (24 for then nonce, plus the 16 added to create the secret box) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad251d922423ab480558e97b31012293f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad251d922423ab480558e97b31012293f">&#9670;&nbsp;</a></span>SymmetricKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymmetricKey::SymmetricKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seedString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>recipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> by (re)deriving it from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedString</td><td>The private seed which is used to generate the key. Anyone who knows (or can guess) this seed can re-generate the key by passing it along with the recipe. </td></tr>
    <tr><td class="paramname">recipe</td><td>The recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6189ca51ec682a30a1c440231a0ef9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6189ca51ec682a30a1c440231a0ef9c4">&#9670;&nbsp;</a></span>deriveFromSeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_symmetric_key.html">SymmetricKey</a> SymmetricKey::deriveFromSeed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seedString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>recipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> by (re)deriving it from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedString</td><td>The private seed which is used to generate the key. Anyone who knows (or can guess) this seed can re-generate the key by passing it along with the recipe. </td></tr>
    <tr><td class="paramname">recipe</td><td>The recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96161ba0e7d4d96ccd30dfd7d47787e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96161ba0e7d4d96ccd30dfd7d47787e9">&#9670;&nbsp;</a></span>fromSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_symmetric_key.html">SymmetricKey</a> SymmetricKey::fromSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>serializedBinaryForm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize from a byte array stored as a list of: (keyBytes, recipe) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays. </p>

</div>
</div>
<a id="a9f9b903963307affd8b0208b8e3c405d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9b903963307affd8b0208b8e3c405d">&#9670;&nbsp;</a></span>seal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> SymmetricKey::seal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. It can be used to pair a sealed message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the recipe in JSON Format for Recipes,...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="a91dd00fb5e887c18a0e7abd6a8eca25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dd00fb5e887c18a0e7abd6a8eca25d">&#9670;&nbsp;</a></span>seal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> SymmetricKey::seal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. It can be used to pair a sealed message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the recipe in JSON Format for Recipes,...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="ab7806c51b1f13910a077d9477a332ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7806c51b1f13910a077d9477a332ad4">&#9670;&nbsp;</a></span>seal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> SymmetricKey::seal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. It can be used to pair a sealed message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the recipe in JSON Format for Recipes,...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="ad3facff0484c08bf0bcf478bf1e31afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3facff0484c08bf0bcf478bf1e31afe">&#9670;&nbsp;</a></span>seal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> SymmetricKey::seal </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the plaintext message to seal </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. It can be used to pair a sealed message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the recipe in JSON Format for Recipes,...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="a98bad48113a156c2d020509d45cdb2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bad48113a156c2d020509d45cdb2e6">&#9670;&nbsp;</a></span>sealToCiphertextOnly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; SymmetricKey::sealToCiphertextOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. It can be used to pair a sealed message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; The sealed <em>ciphertext</em> without the additional context needed to unseal (the recipe required to re-derive the key and any unsealingInstructions which must match on unsealing.) </dd></dl>

</div>
</div>
<a id="a1b9a9e571e4ea58c25ea64d4f8679b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9a9e571e4ea58c25ea64d4f8679b0a">&#9670;&nbsp;</a></span>sealToCiphertextOnly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; SymmetricKey::sealToCiphertextOnly </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the plaintext message in bytes </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; The sealed <em>ciphertext</em> without the additional context needed to unseal (the recipe required to re-derive the key and any unsealingInstructions which must match on unsealing.) </dd></dl>

</div>
</div>
<a id="a94f3752039f5735b504f071d710ac01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f3752039f5735b504f071d710ac01b">&#9670;&nbsp;</a></span>toJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SymmetricKey::toJson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize this object to a JSON-formatted string. </p>
<p>It can be reconstituted by calling the constructor with this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indent</td><td>The number of characters to indent the JSON (optional) </td></tr>
    <tr><td class="paramname">indent_char</td><td>The character with which to indent the JSON (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string A <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> serialized to JSON format. </dd></dl>

</div>
</div>
<a id="aac1f3f4afd908aba2f5780f2248a8f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1f3f4afd908aba2f5780f2248a8f47">&#9670;&nbsp;</a></span>toSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SymmetricKey::toSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize to byte array as a list of: (keyBytes, recipe) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays. </p>

</div>
</div>
<a id="aea2300f36bf74e3d64dc71c35e81d32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2300f36bf74e3d64dc71c35e81d32e">&#9670;&nbsp;</a></span>unseal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SymmetricKey::unseal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>packagedSealedMessage</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unseal a message by re-deriving the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from a seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packagedSealedMessage</td><td>The message to be unsealed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a> The plaintesxt message that had been sealed </dd></dl>

</div>
</div>
<a id="a74190d5c5f3a46e6c5f4e131e6f3d5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74190d5c5f3a46e6c5f4e131e6f3d5a1">&#9670;&nbsp;</a></span>unseal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SymmetricKey::unseal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>packagedSealedMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seedString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unseal a message by re-deriving the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> from a seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedString</td><td>The seed string used to generate the <a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a> that sealed this message </td></tr>
    <tr><td class="paramname">packagedSealedMessage</td><td>The message to be unsealed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a> The plaintesxt message that had been sealed </dd></dl>

</div>
</div>
<a id="a835fa33240e815ee23d822dd58bae669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835fa33240e815ee23d822dd58bae669">&#9670;&nbsp;</a></span>unseal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SymmetricKey::unseal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unseal a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>The sealed message to be unsealed </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional value was set during the <a class="el" href="class_symmetric_key.html#a9f9b903963307affd8b0208b8e3c405d" title="Seal a plaintext message.">SymmetricKey::seal</a> operation, the same value must be provided to unseal the message or the operation will fail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_cryptographic_verification_failure_exception.html" title="Thrown when a cryptographic operation fails due to keys or data being corrupted, modified,...">CryptographicVerificationFailureException</a></td><td>Thrown if the ciphertext is not valid and cannot be unsealed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7f30cb5066e2cc943aa3490b2a58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7f30cb5066e2cc943aa3490b2a58e8">&#9670;&nbsp;</a></span>unseal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SymmetricKey::unseal </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ciphertextLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unsealingInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unseal a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext</td><td>The sealed message to be unsealed </td></tr>
    <tr><td class="paramname">ciphertextLength</td><td>The length of the sealed message </td></tr>
    <tr><td class="paramname">unsealingInstructions</td><td>If this optional value was set during the <a class="el" href="class_symmetric_key.html#a9f9b903963307affd8b0208b8e3c405d" title="Seal a plaintext message.">SymmetricKey::seal</a> operation, the same value must be provided to unseal the message or the operation will fail. It can be used to pair a secret (sealed) message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_cryptographic_verification_failure_exception.html" title="Thrown when a cryptographic operation fails due to keys or data being corrupted, modified,...">CryptographicVerificationFailureException</a></td><td>Thrown if the ciphertext is not valid and cannot be unsealed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3c037459d7ccb3c6eac890d9eceb3289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c037459d7ccb3c6eac890d9eceb3289">&#9670;&nbsp;</a></span>keyBytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SymmetricKey::keyBytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary representation of the symmetric key. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/<a class="el" href="symmetric-key_8hpp_source.html">symmetric-key.hpp</a></li>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/symmetric-key.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_symmetric_key.html">SymmetricKey</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
