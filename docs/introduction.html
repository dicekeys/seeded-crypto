<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DiceKeys Seeded Cryptography Library: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DiceKeys Seeded Cryptography Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('introduction.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__Users_stuart_git_dicekeys_seeded_crypto_doxygen_Introduction"></a> This Seeded Cryptography Library was written to support the DiceKeys project.</p>
<p>It is an <em>object oriented</em> cryptographic library, with keys (<a class="el" href="class_symmetric_key.html" title="A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...">SymmetricKey</a>, <a class="el" href="class_unsealing_key.html" title="an UnsealingKey is used to unseal messages sealed with its corresponding SealingKey....">UnsealingKey</a> &amp; <a class="el" href="class_sealing_key.html" title="A sealingKeyBytes is used to seal messages, in combination with a UnsealingKey which can unseal them....">SealingKey</a>, <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> &amp; <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a>) as first-class objects, and cryptographic operations implemented as methods on those keys. It also supports a derived <a class="el" href="class_secret.html" title="A secret derived from a seed string and set of options in JSON Format for Recipes.">Secret</a> class, into which cryptographic-strength secrets can be derived and shared with clients that want to implement their own operations.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="class_symmetric_key.html">SymmetricKey</a> sk(...);</div>
<div class="line"><span class="keyword">const</span> std::string plaintext(<span class="stringliteral">&quot;Wait long enough, and grilled cheese becomes its own spoonerism.&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> sealed_message = sk.seal(plaintext);</div>
<div class="ttc" id="aclass_symmetric_key_html"><div class="ttname"><a href="class_symmetric_key.html">SymmetricKey</a></div><div class="ttdoc">A SymmetricKey can be used to seal and unseal messages. This SymmetricKey class can be (re) derived f...</div><div class="ttdef"><b>Definition:</b> symmetric-key.hpp:39</div></div>
</div><!-- fragment --><p>All keys and secrets are derived from <em>seed</em> strings, using options specified in the <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. This is different from most other libraries, where keys are generated using a random number generator. You can still create keys using the random number generator with this library, but you would do so by having the generator create a random seed string.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="class_unsealing_key.html">UnsealingKey</a> private_key = <a class="code" href="class_unsealing_key.html#ac94f372fca0a431fb1595992e6d210db">UnsealingKey::deriveFromSeed</a>(</div>
<div class="line">    <span class="comment">// The seed string. Hopefully better than Randall Munroe&#39;s</span></div>
<div class="line">    <span class="stringliteral">&quot;valid equine capacitor paperclip wrong bovine ground luxury&quot;</span>,</div>
<div class="line">    <span class="comment">// Since the seed is still a bit short, use a memory-hard</span></div>
<div class="line">    <span class="comment">// derivation function to derive the key, not just a simple hash.</span></div>
<div class="line">    <span class="stringliteral">&quot;{hashFunction:\&quot;Argon2id\&quot;}&quot;</span></div>
<div class="line">);</div>
<div class="ttc" id="aclass_unsealing_key_html"><div class="ttname"><a href="class_unsealing_key.html">UnsealingKey</a></div><div class="ttdoc">an UnsealingKey is used to unseal messages sealed with its corresponding SealingKey....</div><div class="ttdef"><b>Definition:</b> unsealing-key.hpp:17</div></div>
<div class="ttc" id="aclass_unsealing_key_html_ac94f372fca0a431fb1595992e6d210db"><div class="ttname"><a href="class_unsealing_key.html#ac94f372fca0a431fb1595992e6d210db">UnsealingKey::deriveFromSeed</a></div><div class="ttdeci">static UnsealingKey deriveFromSeed(const std::string &amp;seedString, const std::string &amp;recipe)</div><div class="ttdoc">Construct a new UnsealingKey by deriving a public/private key pair from a seed string and a set of re...</div><div class="ttdef"><b>Definition:</b> unsealing-key.cpp:45</div></div>
</div><!-- fragment --><p>Like <a href="https://libsodium.gitbook.io/doc/">LibSodium</a>, the cryptographic library on which the Seeded Cryptography Library is built, this library is opinionated. It offers a small number of safe options to direct users to good choices, rather than offering a wide variety with some potentially-dangerous choices. For example, instead of <em>encrypt</em> and <em>decrypt</em> operations, the library supports only <em>seal</em> and <em>unseal</em>. The difference is that sealing a message always attaches a message authentication code (MAC) to the ciphertext, and unsealing always ensures that the ciphertext has not been modified by checking the MAC. The seal operation also packages the ciphertext along with the recipe needed to derive the key needed to unseal the message from the seed.</p>
<p>When sealing data, you can also attach a string that must be known to anyone unsealing the message. This is separate from the key and is included in plaintext in <a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the recipe in JSON Format for Recipes,...">PackagedSealedMessage</a> returned by the seal operation. You can use it, for example, to attach instructions about how such messages should be treated when unsealing. Those instructions are public, and not encrypted. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="class_symmetric_key.html">SymmetricKey</a> sk(...);</div>
<div class="line"><span class="keyword">const</span> std::string plaintext(<span class="stringliteral">&quot;Wait long enough, and grilled cheese becomes its own spoonerism.&quot;</span>)</div>
<div class="line">const std::<span class="keywordtype">string</span> unsealing_instructions(</div>
<div class="line">    &quot;Unsealed messages should be shared only with those who like wordplay.&quot;</div>
<div class="line">);</div>
<div class="line">const auto sealed_message = sk.seal(plaintext, unsealing_instructions);</div>
</div><!-- fragment --><p>All keys and packaged messages in this library can be easily serialized into either JSON format or a binary format, and deserialized, freeing those using the library from having to implement their own serialization methods.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> public_key = <a class="code" href="class_sealing_key.html">SealingKey</a>.<a class="code" href="class_sealing_key.html#a67d9408d93e61f0b26ed2194d3231954">fromJson</a>(SealingKeyAsJson);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="class_sodium_buffer.html">SodiumBuffer</a> public_key_as_binary = public_key.toSerializedBinaryForm();</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="class_sealing_key.html">SealingKey</a> copy_of_public_key = <a class="code" href="class_sealing_key.html">SealingKey</a>.<a class="code" href="class_sealing_key.html#a11faf194c22483e5933cccf0ae0f75fd">fromSerializedBinaryForm</a>(public_key_as_binary);</div>
<div class="ttc" id="aclass_sealing_key_html"><div class="ttname"><a href="class_sealing_key.html">SealingKey</a></div><div class="ttdoc">A sealingKeyBytes is used to seal messages, in combination with a UnsealingKey which can unseal them....</div><div class="ttdef"><b>Definition:</b> sealing-key.hpp:36</div></div>
<div class="ttc" id="aclass_sealing_key_html_a11faf194c22483e5933cccf0ae0f75fd"><div class="ttname"><a href="class_sealing_key.html#a11faf194c22483e5933cccf0ae0f75fd">SealingKey::fromSerializedBinaryForm</a></div><div class="ttdeci">static SealingKey fromSerializedBinaryForm(const SodiumBuffer &amp;serializedBinaryForm)</div><div class="ttdoc">Deserialize from a byte array stored as a list of: (sealingKeyBytes, recipe)</div><div class="ttdef"><b>Definition:</b> sealing-key.cpp:156</div></div>
<div class="ttc" id="aclass_sealing_key_html_a67d9408d93e61f0b26ed2194d3231954"><div class="ttname"><a href="class_sealing_key.html#a67d9408d93e61f0b26ed2194d3231954">SealingKey::fromJson</a></div><div class="ttdeci">static SealingKey fromJson(const std::string &amp;sealingKeyAsJson)</div><div class="ttdoc">Construct a sealingKeyBytes from a JSON string.</div><div class="ttdef"><b>Definition:</b> sealing-key.cpp:23</div></div>
<div class="ttc" id="aclass_sodium_buffer_html"><div class="ttname"><a href="class_sodium_buffer.html">SodiumBuffer</a></div><div class="ttdoc">A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...</div><div class="ttdef"><b>Definition:</b> sodium-buffer.hpp:27</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md0"></a>
Seeding with DiceKeys</h1>
<p>DiceKeys are converted into strings by generating a three-character ASCII/UTF8 triple for each die:</p>
<ul>
<li>An uppercase letter: '<code>A</code>'-'<code>Z</code>' excluding '<code>Q</code>'</li>
<li>An digit: '<code>1</code>'-'<code>6</code>' (not to be confused for )</li>
<li><p class="startli">A lowercase orientation letter:</p><ul>
<li>'<code>t</code>' if the top of the die as read faces the *t*op of box (it is upright)</li>
<li>'<code>r</code>' if the top of the die as read faces the *r*ight side of box, or 90 degrees clockwise from upright</li>
<li>'<code>b</code>' if the top of the die as read faces the *b*ottom of box, or 180 degrees clockwise from upright</li>
<li>'<code>l</code>' if the top of the die as read faces the *l*eft side of box, or 270 degrees clockwise from upright.</li>
</ul>
<p class="startli">This convention matches the naming conventions of CSS boxes (e.g. <code>margin-[top|left|bottom|right]</code>), rectangles in the browser Document Object Model (DOM), and forms the pronounceable acronym <code>trbl</code> which lends itself to the memory mnemonic of "[right here in river city.](https://en.wikipedia.org/wiki/Ya_Got_Trouble)"</p>
</li>
</ul>
<p>The three-character triples are concatenated English reading order, starting at the top left and proceeding across the row, and then down each row until reaching the bottom right. A DiceKey with 25 dice will yield a 75-character string.</p>
<p>The DiceKey itself may be read in one of four possible orientations, and changing the orientation at which a DiceKey is read should not change the secrets it generates. Thus, the seed string should represent a <em>canonical</em> orientation of the key.</p>
<p>While DiceKeys hardware with a hinged lid may seemingly have a predefined canonical top that might be detectable to a machine vision algorithm, not all DiceKeys hardware will have a canonical top. For example, a DiceKey made from stickers (STICKIES) are squares and have no defined top.</p>
<p>Thus, the canonical top left of a DiceKey is the one that produces a string that representation with the earliest sort order. One cannot simply assume that a corner die alone will be sufficient to indicate sort order (e.g., assuming that a corner with <code>A1</code> must be the top left), because a DiceKey could have more than one <code>A</code>. (DiceKeys are currently packaged with 25 unique dice, but users should be allowed to two sets together when generating two DiceKeys and still expect the software to function reliably.) Rather, to determine the correct seed string algorithmically, generate all four possible string representations of the DiceKey and take the earliest in sort order. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
