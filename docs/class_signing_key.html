<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DiceKeys Seeded Cryptography Library: SigningKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DiceKeys Seeded Cryptography Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_signing_key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_signing_key-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SigningKey Class Reference<div class="ingroups"><a class="el" href="group___derived_from_seeds.html">Derived Keys</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>SigningKeys generate <em>signatures</em> of messages which can then be used by the corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that a message was signed by can confirm that the message was indeed signed by the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> and has not since been tampered with.  
 <a href="class_signing_key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="signing-key_8hpp_source.html">signing-key.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab069912ec28952de43e5fd1722e4882c"><td class="memItemLeft" align="right" valign="top"><a id="ab069912ec28952de43e5fd1722e4882c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ab069912ec28952de43e5fd1722e4882c">SigningKey</a> (const <a class="el" href="class_signing_key.html">SigningKey</a> &amp;other)</td></tr>
<tr class="memdesc:ab069912ec28952de43e5fd1722e4882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of another <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a>. <br /></td></tr>
<tr class="separator:ab069912ec28952de43e5fd1722e4882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73556de3c21e7dd4e1afe15d5b79893c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a73556de3c21e7dd4e1afe15d5b79893c">SigningKey</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;<a class="el" href="class_signing_key.html#ace2901409405775e50558dd922b4d206">signingKeyBytes</a>, const std::string &amp;<a class="el" href="class_signing_key.html#a4f6e044a83613bde16e447e65562b1e3">recipe</a>)</td></tr>
<tr class="memdesc:a73556de3c21e7dd4e1afe15d5b79893c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from the objects members.  <a href="class_signing_key.html#a73556de3c21e7dd4e1afe15d5b79893c">More...</a><br /></td></tr>
<tr class="separator:a73556de3c21e7dd4e1afe15d5b79893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea874c69b75b9fa41f4b484e07ae6f20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aea874c69b75b9fa41f4b484e07ae6f20">SigningKey</a> (const std::string &amp;seedString, const std::string &amp;<a class="el" href="class_signing_key.html#a4f6e044a83613bde16e447e65562b1e3">recipe</a>)</td></tr>
<tr class="memdesc:aea874c69b75b9fa41f4b484e07ae6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> by deriving a signing key pair from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>.  <a href="class_signing_key.html#aea874c69b75b9fa41f4b484e07ae6f20">More...</a><br /></td></tr>
<tr class="separator:aea874c69b75b9fa41f4b484e07ae6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b1c8d470ba5506f4ffdb4a408e3da0"><td class="memItemLeft" align="right" valign="top"><a id="aa9b1c8d470ba5506f4ffdb4a408e3da0"></a>
const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aa9b1c8d470ba5506f4ffdb4a408e3da0">getSeedBytes</a> () const</td></tr>
<tr class="memdesc:aa9b1c8d470ba5506f4ffdb4a408e3da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the 32-byte private seed (the compact representation of the private key) from the 64-byte sodium private key (which contains a copy of the public key, which sodium stores so as to avoid unnecessary computation when the public key is needed). <br /></td></tr>
<tr class="separator:aa9b1c8d470ba5506f4ffdb4a408e3da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa52eb5128fbae4456866344a0e6562"><td class="memItemLeft" align="right" valign="top"><a id="affa52eb5128fbae4456866344a0e6562"></a>
const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#affa52eb5128fbae4456866344a0e6562">getSignatureVerificationKeyBytes</a> () const</td></tr>
<tr class="memdesc:affa52eb5128fbae4456866344a0e6562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw binary representation of the signature-verification key, re-deriving them from the signing key if signatureVerificationKeyBytes is a zero-length vector. <br /></td></tr>
<tr class="separator:affa52eb5128fbae4456866344a0e6562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820b7e090433f7e7ebad5ea691356c4b"><td class="memItemLeft" align="right" valign="top"><a id="a820b7e090433f7e7ebad5ea691356c4b"></a>
const <a class="el" href="class_signature_verification_key.html">SignatureVerificationKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a820b7e090433f7e7ebad5ea691356c4b">getSignatureVerificationKey</a> () const</td></tr>
<tr class="memdesc:a820b7e090433f7e7ebad5ea691356c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> which is used to verify signatures generated with this <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a>. <br /></td></tr>
<tr class="separator:a820b7e090433f7e7ebad5ea691356c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad409117fbbf4bf199fe6cf890d40d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aa5ad409117fbbf4bf199fe6cf890d40d">generateSignature</a> (const unsigned char *message, const size_t messageLength) const</td></tr>
<tr class="memdesc:aa5ad409117fbbf4bf199fe6cf890d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a signature for a message which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key.  <a href="class_signing_key.html#aa5ad409117fbbf4bf199fe6cf890d40d">More...</a><br /></td></tr>
<tr class="separator:aa5ad409117fbbf4bf199fe6cf890d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856e47b69b3a643eb2b4ecf2457a2b7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ad856e47b69b3a643eb2b4ecf2457a2b7">generateSignature</a> (const std::vector&lt; unsigned char &gt; &amp;message) const</td></tr>
<tr class="memdesc:ad856e47b69b3a643eb2b4ecf2457a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a signature for a message, which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key.  <a href="class_signing_key.html#ad856e47b69b3a643eb2b4ecf2457a2b7">More...</a><br /></td></tr>
<tr class="separator:ad856e47b69b3a643eb2b4ecf2457a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586ebeef4ff3790ab2f15efeeaca6b53"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a586ebeef4ff3790ab2f15efeeaca6b53">toJson</a> (int indent=-1, const char indent_char=' ') const</td></tr>
<tr class="memdesc:a586ebeef4ff3790ab2f15efeeaca6b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this object to a JSON-formatted string.  <a href="class_signing_key.html#a586ebeef4ff3790ab2f15efeeaca6b53">More...</a><br /></td></tr>
<tr class="separator:a586ebeef4ff3790ab2f15efeeaca6b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3e30ba725366bd95e5142befe200a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#aae3e30ba725366bd95e5142befe200a2">toSerializedBinaryForm</a> () const</td></tr>
<tr class="memdesc:aae3e30ba725366bd95e5142befe200a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to byte array as a list of: (keyBytes, signatureVerificationKeyBytes, recipe)  <a href="class_signing_key.html#aae3e30ba725366bd95e5142befe200a2">More...</a><br /></td></tr>
<tr class="separator:aae3e30ba725366bd95e5142befe200a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9050484622eb8976da528d9cb10936e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_signing_key.html">SigningKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a9050484622eb8976da528d9cb10936e4">deriveFromSeed</a> (const std::string &amp;seedString, const std::string &amp;<a class="el" href="class_signing_key.html#a4f6e044a83613bde16e447e65562b1e3">recipe</a>)</td></tr>
<tr class="memdesc:a9050484622eb8976da528d9cb10936e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> by deriving a signing key pair from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>.  <a href="class_signing_key.html#a9050484622eb8976da528d9cb10936e4">More...</a><br /></td></tr>
<tr class="separator:a9050484622eb8976da528d9cb10936e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdf9ebd2d3cc82b7bb2b2482514cb4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_signing_key.html">SigningKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a4bdf9ebd2d3cc82b7bb2b2482514cb4c">fromJson</a> (const std::string &amp;signingKeyAsJson)</td></tr>
<tr class="memdesc:a4bdf9ebd2d3cc82b7bb2b2482514cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct (reconsitute) the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> from JSON format. The JSON object may or may not contain the signatureVerificationKeyBytes. If it does not, an empty byte vector will be stored and the verification key bytes will be re-derived from the signing key by getSignatureVerificationKeyBytes if they are needed.  <a href="class_signing_key.html#a4bdf9ebd2d3cc82b7bb2b2482514cb4c">More...</a><br /></td></tr>
<tr class="separator:a4bdf9ebd2d3cc82b7bb2b2482514cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d31e359b0303af20af440030a11019"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_signing_key.html">SigningKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a57d31e359b0303af20af440030a11019">fromSerializedBinaryForm</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;serializedBinaryForm)</td></tr>
<tr class="memdesc:a57d31e359b0303af20af440030a11019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize from a byte array stored as a list of: (keyBytes, signatureVerificationKeyBytes, recipe)  <a href="class_signing_key.html#a57d31e359b0303af20af440030a11019">More...</a><br /></td></tr>
<tr class="separator:a57d31e359b0303af20af440030a11019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ace2901409405775e50558dd922b4d206"><td class="memItemLeft" align="right" valign="top"><a id="ace2901409405775e50558dd922b4d206"></a>
const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#ace2901409405775e50558dd922b4d206">signingKeyBytes</a></td></tr>
<tr class="memdesc:ace2901409405775e50558dd922b4d206"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw binary representation of the cryptographic signing key. <br /></td></tr>
<tr class="separator:ace2901409405775e50558dd922b4d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6e044a83613bde16e447e65562b1e3"><td class="memItemLeft" align="right" valign="top"><a id="a4f6e044a83613bde16e447e65562b1e3"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_signing_key.html#a4f6e044a83613bde16e447e65562b1e3">recipe</a></td></tr>
<tr class="memdesc:a4f6e044a83613bde16e447e65562b1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="recipe_format.html">JSON Format for Recipes</a> string used to specify how this key is derived. <br /></td></tr>
<tr class="separator:a4f6e044a83613bde16e447e65562b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SigningKeys generate <em>signatures</em> of messages which can then be used by the corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that a message was signed by can confirm that the message was indeed signed by the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> and has not since been tampered with. </p>
<p>The corresponding <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> can be obtained by calling getSignatureVerificationKey.</p>
<p>The key pair of the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> and <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> is generated from a seed and a set of options in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a73556de3c21e7dd4e1afe15d5b79893c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73556de3c21e7dd4e1afe15d5b79893c">&#9670;&nbsp;</a></span>SigningKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SigningKey::SigningKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>signingKeyBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>recipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from the objects members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signingKeyBytes</td><td>may either be a 32-byte ED25519 seed or a 64-byte sodium-style private signing key which embeds the public key so that it doesn't have to be re-computed. If the 32-byte seed is provided, the constructor will compute the 64-byte sodium-style key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea874c69b75b9fa41f4b484e07ae6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea874c69b75b9fa41f4b484e07ae6f20">&#9670;&nbsp;</a></span>SigningKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SigningKey::SigningKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seedString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>recipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> by deriving a signing key pair from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedString</td><td>The private seed which is used to generate the key pair. Anyone who knows (or can guess) this seed can re-generate the key pair by passing it along with the recipe. </td></tr>
    <tr><td class="paramname">recipe</td><td>The recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9050484622eb8976da528d9cb10936e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9050484622eb8976da528d9cb10936e4">&#9670;&nbsp;</a></span>deriveFromSeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_signing_key.html">SigningKey</a> SigningKey::deriveFromSeed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seedString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>recipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> by deriving a signing key pair from a seed string and a set of recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedString</td><td>The private seed which is used to generate the key pair. Anyone who knows (or can guess) this seed can re-generate the key pair by passing it along with the recipe. </td></tr>
    <tr><td class="paramname">recipe</td><td>The recipe in <a class="el" href="recipe_format.html">JSON Format for Recipes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bdf9ebd2d3cc82b7bb2b2482514cb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdf9ebd2d3cc82b7bb2b2482514cb4c">&#9670;&nbsp;</a></span>fromJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_signing_key.html">SigningKey</a> SigningKey::fromJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signingKeyAsJson</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct (reconsitute) the <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> from JSON format. The JSON object may or may not contain the signatureVerificationKeyBytes. If it does not, an empty byte vector will be stored and the verification key bytes will be re-derived from the signing key by getSignatureVerificationKeyBytes if they are needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signingKeyAsJson</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57d31e359b0303af20af440030a11019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d31e359b0303af20af440030a11019">&#9670;&nbsp;</a></span>fromSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_signing_key.html">SigningKey</a> SigningKey::fromSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>serializedBinaryForm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize from a byte array stored as a list of: (keyBytes, signatureVerificationKeyBytes, recipe) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays. </p>

</div>
</div>
<a id="ad856e47b69b3a643eb2b4ecf2457a2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad856e47b69b3a643eb2b4ecf2457a2b7">&#9670;&nbsp;</a></span>generateSignature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; SigningKey::generateSignature </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a signature for a message, which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to <em>sign</em> by generating the signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; A signature, which can be used with the <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to prove that this act of signing (this call to generateSignature) took place. </dd></dl>

</div>
</div>
<a id="aa5ad409117fbbf4bf199fe6cf890d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ad409117fbbf4bf199fe6cf890d40d">&#9670;&nbsp;</a></span>generateSignature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; SigningKey::generateSignature </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a signature for a message which can be used by the corresponding public <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to verify that this message was, in fact, signed by this key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to <em>sign</em> by generating the signature </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; A signature, which can be used with the <a class="el" href="class_signature_verification_key.html" title="A SignatureVerificationKey is used to verify that messages were signed by its corresponding SigningKe...">SignatureVerificationKey</a> to prove that this act of signing (this call to generateSignature) took place. </dd></dl>

</div>
</div>
<a id="a586ebeef4ff3790ab2f15efeeaca6b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586ebeef4ff3790ab2f15efeeaca6b53">&#9670;&nbsp;</a></span>toJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SigningKey::toJson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize this object to a JSON-formatted string. </p>
<p>It can be reconstituted by calling the constructor with this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater</td><td>The JSON-encoding will always include the binary signing key bytes (in hex format) and the keyDerviationOptionsJson used to derive the key, but the signature-verification key bytes will not be included unless you set this value to false. Rather, if it is elided, the signature-verification key can be reconstituted from the signing-key after the object is reconstituted, which takes a little computation in return for the space saved in the JSON format. </td></tr>
    <tr><td class="paramname">indent</td><td>The number of characters to indent the JSON (optional) </td></tr>
    <tr><td class="paramname">indent_char</td><td>The character with which to indent the JSON (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string </dd></dl>

</div>
</div>
<a id="aae3e30ba725366bd95e5142befe200a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3e30ba725366bd95e5142befe200a2">&#9670;&nbsp;</a></span>toSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> SigningKey::toSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize to byte array as a list of: (keyBytes, signatureVerificationKeyBytes, recipe) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimizeSizeByRemovingTheSignatureVerificationKeyBytesWhichCanBeRegeneratedLater</td><td>If set to true (the default), an empty buffer will be passed for the signatureVerificationKeyBytes. After the object is deserialized, the replica can re-generate a signature-verification key from the signing key, which takes a little computation in return for the 28 bytes saved in this format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/<a class="el" href="signing-key_8hpp_source.html">signing-key.hpp</a></li>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/signing-key.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_signing_key.html">SigningKey</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
