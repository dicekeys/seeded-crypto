#pragma once

#include <cassert>
#include <sodium.h>
#include <vector>
#include <string>

#include "sodium-buffer.hpp"

/**
 * @brief A SignatureVerificationKey is used to verify that messages were
 * signed by its corresponding SigningKey.
 * SigningKeys generate _signatures_, and by verifying a message/signature
 * pair the SignatureVerificationKey can confirm that the message was
 * indeed signed using the SigningKey.
 * The key pair of the SigningKey and SignatureVerificationKey is generated
 * from a seed and a set of options in
 *  @ref recipe_format.
 * 
 * To derive a SignatureVerificationKey from a seed, first derive the
 * corresponding SigningKey and then call SigningKey::getSignatureVerificationKey.
 * 
 * @ingroup DerivedFromSeeds
 */
class SignatureVerificationKey {
public:
  /**
   * @brief The raw binary representation of the cryptographic key
   */
  const std::vector<unsigned char> signatureVerificationKeyBytes;
  /**
   * @brief A @ref recipe_format string used to specify how this key is derived.
   */
  const std::string recipe;
 
  /**
  * @brief Construct by passing the classes members
  * 
  * @param keyBytes 
  * @param recipe 
  */
  SignatureVerificationKey(
    const std::vector<unsigned char> &keyBytes,
    const std::string& recipe
  );

  /**
   * @brief Construct (reconstitute) a SignatureVerificationKey from JSON format,
   * which may ahve been generated by calling toJson on another SignatureVerificationKey.
   * 
   * @param signatureVerificationKeyAsJson 
   */
  static SignatureVerificationKey fromJson(
    const std::string& signatureVerificationKeyAsJson
  );

  /**
   * @brief Serialize this object to a JSON-formatted string
   * 
   * It can be reconstituted by calling the constructor with this string.
   * 
   * @param indent The number of characters to indent the JSON (optional)
   * @param indent_char The character with which to indent the JSON (optional)
   * @return const std::string
   */
  const std::string toJson(
    int indent = -1,
    const char indent_char = ' '
  ) const;

/**
 * This wrapper around LibSodium's signature-verification function
 * is private because while the other static methods are _discouraged_,
 * they will at least check that the caller is passing a key and
 * signature of the correct length.  Since they provide the exact same
 * functionality after those checks are made, they should _always_
 * be used and this method should only ever be called by them.
 */
private:
  static bool verify(
    const unsigned char* signatureVerificationKeyBytes,
    const unsigned char* message,
    const size_t messageLength,
    const unsigned char* signature
  );

public:
  /**
   * @brief *Avoid Using* Verify a message's signature using a
   * raw libsodium verification key
   * 
   * Instead of using this static method, we recommend you use the seal
   * method on an instance of a SignatureVerificationKey object.
   * 
   * @param signatureVerificationKeyBytes signatureVerificationKeyBytes The raw key bytes
   * @param signatureVerificationKeyBytesLength The length of the raw key bytes
   * @param message The message that was signed
   * @param messageLength The length of the message that was signed
   * @param signature The signature generated by corresponding SigningKey when
   * by calling SigningKey::generateSignature with the same message.
   * @param signatureLength The length of the signature
   * @return true if the signature is valid indicating the message was indeed
   * signed by the corresponding SigningKey
   * @return false if the verification fails.
   */
  static bool verify(
    const unsigned char* signatureVerificationKeyBytes,
    const size_t signatureVerificationKeyBytesLength,
    const unsigned char* message,
    const size_t messageLength,
    const unsigned char* signature,
    const size_t signatureLength
  );

  /**
   * @brief *Avoid Using* Verify a message's signature using a
   * raw libsodium verification key
   * 
   * Instead of using this static method, we recommend you use the seal
   * method on an instance of a SignatureVerificationKey object.
   * 
   * @param signatureVerificationKeyBytes signatureVerificationKeyBytes The raw key bytes
   * @param message The message that was signed
   * @param messageLength The length of the message
   * @param signature The signature generated by corresponding SigningKey when
   * by calling SigningKey::generateSignature with the same message.
   * @return true if the signature is valid indicating the message was indeed
   * signed by the corresponding SigningKey
   * @return false if the verification fails.
   */
  static bool verify(
    const std::vector<unsigned char>& signatureVerificationKeyBytes,
    const unsigned char* message,
    const size_t messageLength,
    const std::vector<unsigned char>& signature
  );

  /**
   * @brief Verify that a signature is valid in order to prove that a message
   * has been signed with the SigningKey from which this SignatureVerificationKey
   * was generated.
   * 
   * @param message The message to verify the signature of
   * @param messageLength The length of the message
   * @param signature The signature generated by corresponding SigningKey when
   * by calling SigningKey::generateSignature with the same message.
   * @return true if the signature is valid indicating the message was indeed
   * signed by the corresponding SigningKey
   * @return false if the verification fails.
   */
  bool verify(
    const unsigned char* message,
    const size_t messageLength,
    const std::vector<unsigned char>& signature
  ) const;

  /**
   * @brief Verify that a signature is valid in order to prove that a message
   * has been signed with the SigningKey from which this SignatureVerificationKey
   * was generated.
   * 
   * @param message The message to verify the signature of
   * @param signature The signature generated by corresponding SigningKey when
   * by calling SigningKey::generateSignature with the same message.
   * @return true if the signature is valid indicating the message was indeed
   * signed by the corresponding SigningKey
   * @return false if the verification fails.
   */
  bool verify(
    const std::vector<unsigned char>& message,
    const std::vector<unsigned char>& signature
  ) const;

  /**
   * @brief Verify that a signature is valid in order to prove that a message
   * has been signed with the SigningKey from which this SignatureVerificationKey
   * was generated.
   * 
   * @param message The message to verify the signature of
   * @param signature The signature generated by corresponding SigningKey when
   * by calling SigningKey::generateSignature with the same message.
   * @return true if the signature is valid indicating the message was indeed
   * signed by the corresponding SigningKey
   * @return false if the verification fails.
   */
  bool verify(
    const SodiumBuffer& message,
    const std::vector<unsigned char>& signature
  ) const;

  /**
   * @brief Get the raw signature verification key as a byte vector.
   * 
   * @return const std::vector<unsigned char> 
   */
  const std::vector<unsigned char> getKeyBytes() const;

  /**
   * @brief Get the raw signature-verification key as a string of hex digits
   *
   * @return const std::string a string containing only hex digits (and no "0x").
   */
  const std::string getKeyBytesAsHexDigits() const;

  /**
   * @brief Get the JSON-formatted recipe string used to generate
   * the public-private key pair.
   * 
   * @return const std::string in  @ref recipe_format
   */
  const std::string getRecipeJson() const {
    return recipe; 
  }

  /**
   * @brief Serialize to byte array as a list of:
   *   (signatureVerificationKeyBytes, recipe)
   * 
   * Stored in SodiumBuffer's fixed-length list format.
   * Strings are stored as UTF8 byte arrays.
   */
  const SodiumBuffer toSerializedBinaryForm() const;

  /**
   * @brief Deserialize from a byte array stored as a list of:
   *   (signatureVerificationKeyBytes, recipe)
   * 
   * Stored in SodiumBuffer's fixed-length list format.
   * Strings are stored as UTF8 byte arrays.
   */
  static SignatureVerificationKey fromSerializedBinaryForm(const SodiumBuffer &serializedBinaryForm);

};

